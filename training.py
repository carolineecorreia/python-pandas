# -*- coding: utf-8 -*-
"""Tarefas_Carol_12_06_2020.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dsQJwSwKKw73G8wZfvvAU00ZvP_yWIbi
"""

import pandas as pd
import datetime
import numpy as np
from sklearn.utils import shuffle
import seaborn as sns
#import xlsxwriter

df_A = pd.read_csv("file_A.csv")
df_B = pd.read_csv("file_B.csv")
df_C = pd.read_csv("file_C.csv")
df_D = pd.read_csv("file_D.csv")

df_A.head()

############################## Tarefas ####################################

# 1 - ver o tamanho(número de linhas) dos dataframes 
# 2 - Excluir as duplicatas de cada dataframe (cuidado para não excluir completamente o email repetido)
# 3 - 'juntar' o df B e C 
# 4 - econtrar os emails de (B+C) que estão presentes em A
# 5 - Excluir A,B,C de D 
# 6 - imprimir em um csv todos os emails de B que são @hotmail (não imprimir os index)
# 7 - imprimir em um xlsx todos os emails de B que NÂO são @hotmail (não imprimir os index)
# 8 - Colocar os emails de C em ordem alfabética. 
# 9 - Com a lista C em ordem alfabética, fazer uma mistura aleatória dela
# 10 - Da lista resultante de 9 pegar uma amostra de 200 e-mails. 
# 11 - misturar aleatóriamente a lista D e criar dividir em 10 listas de tamanho aproximadamente iguais (imprimir as 2 primeiras)
# 12 - ler o arquivo de 7
# 13 - Obter a lista de A1 (igual a A) a partir de D (dica: Você pode usar a lista A para essa tarefa)
# 14 - DESAFIO!!!! Descubra quais são as cidades da lista A, B e C usando o arquivo : historico_vagas.csv

########## Dicas e exigências #######################

# Exigência - Não pode usar laço 'if' e nem 'for' para nenhuma dessas tarefas! (Você não precisa)

# Dicas 
# você vai usar algumas funções como: shuffle, split, sample, merge, concat, sort_values, drop_duplicates etc.
# Dica de ouro! Você vai usar uma função desse tipo: 
#df_final  = pd.concat([df1, df2, df2]).drop_duplicates(keep=False)  #descubra o que isso faz... vai te ajudar muito!

#TRANSLATION#

############################## Tasks ################### #################

# 1 - see the size (number of rows) of the dataframes
# 2 - Delete duplicates for each dataframe (be careful not to completely delete duplicate email)
# 3 - 'join' the df B and C
# 4 - find emails from (B + C) that are present in A
# 5 - Delete A, B, C from D
# 6 - print in a csv all emails from B that are @hotmail (do not print the indexes)
# 7 - print to an xlsx all emails from B that are NOT @hotmail (do not print the indexes)
# 8 - Put C emails in alphabetical order.
# 9 - With list C in alphabetical order, make a random mix of it
# 10 - From the resulting list of 9, take a sample of 200 emails.
# 11 - randomly mix the D list and create divide it into 10 lists of approximately equal size (print the first 2)
# 12 - read the 7 file
# 13 - Get the list of A1 (equal to A) from D (hint: You can use list A for this task)
# 14 - CHALLENGE !!!! Find out which cities are on list A, B and C using the file: historico_vagas.csv

########## Tips and requirements ########################

# Requirement - You cannot use an 'if' or 'for' loop for any of these tasks! (You do not need)

# Tips
# you will use some functions like: shuffle, split, sample, merge, concat, sort_values, drop_duplicates etc.
# Golden tip! You will use such a function:
#df_final = pd.concat ([df1, df2, df2]). drop_duplicates (keep = False) #discover what it does ... it will help you a lot!

# 1 - see the size (number of rows) of the dataframes

# 1 - ver o tamanho(número de linhas) dos dataframes

print("Número de linhas de A:", len(df_A))
print("Número de linhas de B:", len(df_B))
print("Número de linhas de C:", len(df_C))
print("Número de linhas de D:", len(df_D))

# 2 - Excluir as duplicatas de cada dataframe (cuidado para não excluir completamente o email repetido)

df_A_removido = df_A.drop_duplicates(subset='Email', keep='first',)
print("Novo número de linhas de A:", len(df_A_removido))


df_B_removido = df_B.drop_duplicates(subset='Email', keep='first')
print("Novo número de linhas de B:", len(df_B_removido))


df_C_removido = df_C.drop_duplicates(subset='Email', keep='first')
print("Novo número de linhas de C:", len(df_C_removido))


df_D_removido = df_D.drop_duplicates(subset='Email', keep='first')
print("Novo número de linhas de D:", len(df_D_removido))

# 3 - 'juntar' o df B e C 

frames = [df_B, df_C]
B_C = pd.concat(frames)

print(len(df_B)+len(df_C))

B_C

# 4 - encontrar os emails de (B+C) que estão presentes em A
from functools import reduce

comumABC = reduce(np.intersect1d, [B_C.Email, df_A])
print(comumABC)
len(comumABC)

# 5 - Excluir A,B,C de D 

df_ABC = pd.DataFrame({'EmailsComunsABC': comumABC[0:12]})

D_semABC  = pd.concat([df_D, df_ABC, df_ABC]).drop_duplicates(keep=False)

D_semABC

# 6 - imprimir em um csv todos os emails de B que são @hotmail (não imprimir os index)

hotmail = df_B_removido[df_B_removido['Email'].str.contains("@hotmail")]
hotmail

hotmail.to_csv(r'hotmail.csv', index = False)

# 7 - imprimir em um xlsx todos os emails de B que NÂO são @hotmail (não imprimir os index)

sem_hotmail = df_B_removido[~df_B_removido['Email'].str.contains("@hotmail")]
sem_hotmail

sem_hotmail.to_csv(r'sem_hotmail.csv', index = False)

# 8 - Colocar os emails de C em ordem alfabética. 

df_C_removido.sort_values(by=['Email'], ascending = True)

# 9 - Com a lista C em ordem alfabética, fazer uma mistura aleatória dela

C_random = df_C_removido.sample(frac=1)

C_random

#10 - Da lista resultante de 9 pegar uma amostra de 200 e-mails. 

C_random.iloc[0:200]

# 11 - misturar aleatóriamente a lista D e criar dividir em 10 listas de tamanho aproximadamente iguais 
#(imprimir as 2 primeiras)

D_random = df_D_removido.sample(frac=1)
print(len(D_random))

D_random1 = D_random.iloc[0:10]

# 14 - DESAFIO!!!! Descubra quais são as cidades da lista A, B e C usando o arquivo : historico_vagas.csv

historico = pd.read_csv("historico_vagas.csv")
historico.rename(columns={"location.city": "Cidade", "hirer.email": "Email"}, inplace =True)
historico.drop_duplicates(subset='Email', keep='first',inplace = True)


lista_emails_A = df_A_removido['Email'].tolist()

cidades_A = historico.loc[historico['Email'].isin(lista_emails_A)]['Cidade']

#print(len(lista_emails_A))
#print(len(df_A_removido))

print('Cidades do emails da lista A:\n')
print(cidades_A)

lista_emails_B = df_B_removido['Email'].tolist()

cidades_B = historico.loc[historico['Email'].isin(lista_emails_B)]['Cidade']

#print(len(lista_emails_B))
#print(len(df_B_removido))

print('\nCidades do emails da lista B:\n')
print(cidades_B)

lista_emails_C = df_C_removido['Email'].tolist()

cidades_C = historico.loc[historico['Email'].isin(lista_emails_C)]['Cidade']

#print(len(lista_emails_C))
#print(len(df_C_removido))

print('\nCidades do emails da lista C:\n')
print(cidades_C)
